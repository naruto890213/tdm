#include <stdio.h>   
#include <sys/types.h>   
#include <sys/socket.h>   
#include <netinet/in.h>   
#include <arpa/inet.h>   
#include <string.h>
#include <stdlib.h>
#include <signal.h>
#include <time.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <sys/epoll.h>
#include <sys/resource.h>
#include <fcntl.h>

#include "sock_base.h"
#include "pravitelib.h"
#include "sub_server_public.h"
#include "errlog.h"
#include "tdm.h"
#include <pthread.h>

/*****************************************************************************************
本文件的函数主要是tdm模块中的操作函数
******************************************************************************************/
//mongoc_client_t *ms_client = NULL;
static char locale_ip[20]; //add by lk 20140305
#define MASK_NUM 0x07

//用于多线程中锁住数据库，使持有同一socket的多线程只能依次发送数据
pthread_mutex_t msg_mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t mysql_mutex = PTHREAD_MUTEX_INITIALIZER;
int mysql_fd = -1;//add by lk 20150628
Mysql_Fd Data_Fd;

typedef struct _tmd_pthread
{
	int client_sockfd;
	int	pthread_type;
	pthread_t client_t;
	char clientIP[40];
	unsigned char imsi[12];
	unsigned char iccid[12];
}tmd_pthread; //tdm线程数据库

typedef struct _TT_local_date
{
	int				flag;
	unsigned char	Data[128];
}TT_local_date;//add by lk 20150227

typedef struct _Web_Data
{
	unsigned char type;
	unsigned char num;
}Web_Data; //add by lk 20150331

/*****************************************************************************************
sigexit：
	输入参数:
		dunno: 扑捉到的信号值
	输出参数：扑捉到相应的信号值，销毁分配的内存空间，退出程序
******************************************************************************************/
int setnonblocking(int sockfd)
{
	if (fcntl(sockfd, F_SETFL, fcntl(sockfd, F_GETFD, 0)|O_NONBLOCK) == -1) 
	{
		return -1;
	}

	return 0;
}

static void sigexit(int dunno)
{
    switch (dunno)
    {
        case SIGHUP:
            printf("Get a signal -- SIGHUP \n");
			ConnectToMysqlDeInit(&Data_Fd);
            exit(-1);
        case SIGINT:
            printf("Get a signal -- SIGINT \n");
			ConnectToMysqlDeInit(&Data_Fd);
            exit(-1);
        case SIGQUIT:
            printf("Get a signal -- SIGQUIT \n");
			ConnectToMysqlDeInit(&Data_Fd);
            exit(-1);
		case SIGSEGV:
            printf("Get a signal -- SIGSEGV \n");
			ConnectToMysqlDeInit(&Data_Fd);
            exit(-1);
    }
}

/*****************************************************************************************
getValue：
	输入参数:
		para: Web结构体指针，用于保存数值
		sn: 用于保存解析出来的SN
		src: 传入的数据
	输出参数：扑捉到相应的信号值，销毁分配的内存空间，退出程序
******************************************************************************************/
void getValue(Web_Data *para, char *sn, char *src, char *dst)
{
    char *str = strstr(src, ":");
    str = strtok(str, ",");
	if(str)
		para->type = atoi(str + 1);

    str = strtok(NULL, ",");
	if(str)
	{
		str = strstr(str, ":");
		memcpy(sn, str + 2, 15);
	}

    str = strtok(NULL, "}");
	if(str)
	{
		str = strstr(str, ":");
		switch(para->type)
		{
			case 8:
			case 10:
			case 11:
			case 15:
				printf("the str is %s, the len of str is %d\n", str + 2, (int)strlen(str + 2));
				memcpy(dst, str + 2, (int)strlen(str + 2) - 1);
				break;
			default:
				para->num = atoi(str + 1);
				break;
		}
	}
}

/*****************************************************************************************
AccessAuth_Result_Pack：
	该函数主要用于对认证结果进行封包处理
	输入参数:
		Src: 设备认证结果结构体指针
		dst: 用于封装认证结果
	输出参数：返回结构体大小
******************************************************************************************/
int AccessAuth_Result_Pack(AccessAuth_Result_t *Src, TD_ComProtocl_SendFrame_t *dst)
{
	unsigned int dst_offset = 0;

	dst->Cmd_TAG = TAG_RESULT_ACCESS_AUTH;
	if(Src->Result < 0)
	{
		dst->FrameSizeH = 0;
		dst->FrameSizeL = 1;
		dst->Result = AA_RESULT_STATE_FAIL;
		dst->Frame_Data[0] = (unsigned char)(Src->ErrCode);
		if(1 == Src->factoryFlag)
		{
			memcpy(dst->Frame_Data + 1, &(Src->ServerInfo), strlen(Src->ServerInfo));
			dst_offset = 5 + strlen(Src->ServerInfo);
			printf("\n");
		}
		else
			dst_offset = 5;
	}
	else //add by lk 20150203
	{
		TD_Result_t para;
		memset(&para, 0, sizeof(para));	

		dst->FrameSizeH = 0;
		dst->Result = AA_RESULT_STATE_SUCCESS;
		dst->FrameSizeL = sizeof(para);

		memcpy(para.imsi, Src->IMSI, LEN_OF_IMSI);
		para.minite_Remain = (int)Src->minite_Remain;
		para.NeedFile = (unsigned char)(Src->NeedFile);
		para.RequestFlag = 0;
		para.UpdateFlag = 0;
		para.Unused[0] = MASK_NUM & (Src->IsApn | Src->IsNet | Src->priority);//add by lk 20150805
		printf("the NeedFile is %d, IsApn is %d, the priority is %d, the Unused[0] is %d\n", Src->NeedFile, Src->IsApn, Src->priority, para.Unused[0]);
		para.Unused[1] = Src->dataLimit;
		para.threshold_data = Src->threshold;
		para.dataSpeed = Src->dataSpeed;
		para.Vusim_Active_Flag = Src->Vusim_Active_Flag;
		dst_offset = 4 + sizeof(para);
		memcpy(dst->Frame_Data, &para, sizeof(para));
	}
	printf("AccessAuth_Result_Pack:dst_offset=%d\n", dst_offset);

	return dst_offset;
}

/*****************************************************************************************
TT_Result_Pack：
	该函数主要是用于处理透传结构体打包
	输入参数:
		Src：需要发送的数据
		Dst: 接收到的数据内容
		num: 结构体实际数据的长度
		CMD：结构体头部的CMD类型
		Result：非零值表示异常，0值表示正常
	输出参数：返回封包后的数据大小
******************************************************************************************/
int TT_Result_Pack(TT_RESULT_t * Src, TD_ComProtocl_SendFrame_t *Dst, int num, int CMD, int Result)
{
	Dst->Cmd_TAG = CMD;
	Dst->FrameSizeH = 0;
	Dst->FrameSizeL = num;
	while(Result > 255)
    {
        Result = Result - 256; //add by lk 20150427
    }

	Dst->Result = Result;
	if(Src != NULL)
		memcpy(Dst->Frame_Data, Src->ReData, num);

	return (int)(4 + num);
}

int TT_Result_Pack1(unsigned char *Src, TD_ComProtocl_SendFrame_t *Dst, int num, int CMD, int Result)
{
	Dst->Cmd_TAG = CMD;
	Dst->FrameSizeH = 0;
	Dst->FrameSizeL = num;
	while(Result > 255)
    {
        Result = Result - 256; //add by lk 20150427
    }

	Dst->Result = Result;
	if(Src != NULL)
		memcpy(Dst->Frame_Data, Src, num);

	return (int)(4 + num);
}

/*****************************************************************************************
TT_Info_Process：
	该函数主要是用于处理TDM和SPM直接的数据交互
	输入参数:
		IMSI：imsi数据
		Src：需要发送的数据
		Dst: 接收到的数据内容
		iLen：需要发送的数据长度
	输出参数：返回交互后的数据长度
******************************************************************************************/
int TT_Info_Process(unsigned char *Src, TT_RESULT_t *Dst, int iLen)
{
    memcpy(Dst->ReData, Src, iLen);

    return iLen;
}

/*****************************************************************************************
getNumber：
	该函数主要是用于解析sim卡激活号码
	输入参数:
		Src：原始数据
		num: 数据长度
	输出参数：返回号码的个数
******************************************************************************************/
int getNumber(char *src, int num)//add by lk 20150306
{
	int i = 0, j;
	char *p = src;

	int n = strlen(src);
	if(n == 0)
	{
		j = 0;
	}
	else
	{
		j = 1;
	}

	while(i < num)
    {
        if(p[i] == ',')
        {
			j++;
        }
        i++;
    }

	return j;
}

/*****************************************************************************************
GetMsgFromSocket：
	该函数主要是用于解析socket收到的数据
	输入参数:
		iclient_sock：socket文件描述符
		num：返回解析后的数据长度
		IMSI：保存解析出来的imsi数据
		TempBuf：保存解析出来除去imsi的其他数据
	输出参数：CMD类型
******************************************************************************************/
int GetMsgFromSocket(int iclient_sock, int *num, unsigned char *IMSI, unsigned char *TempBuf)
{
	int recvbytes = -1;
	int CMD_TAG = -1;
	unsigned char RecvBuf[RecvBufSize] = {'\0'};
	memset(TempBuf, 0, RecvBufSize);

	recvbytes = recv(iclient_sock, (char *)RecvBuf, RecvBufSize, 0);
	if(recvbytes <= 0)
	{
		perror("recv");
		return TAG_ERR;
	}
	
#if 0
	int n;
	for(n = 0; n < recvbytes; n++)
	{
		LogMsg(MSG_MONITOR, "\b%02x ", RecvBuf[n]);
	}
	LogMsg(MSG_MONITOR, "\n");
#endif

	TD_ComProtocl_RecvFrame_t *p_Recv = (TD_ComProtocl_RecvFrame_t *)RecvBuf;
	CMD_TAG = p_Recv->Cmd_TAG;
	if(p_Recv->FrameSize == 0)
	{
		*num = 0;
	}
	else
	{
		*num = p_Recv->FrameSize - 9;
	}

	switch(CMD_TAG)
	{
		case TAG_ACCESS_AUTH:
		case TAG_SIMFILE_REQUEST:
			memcpy(TempBuf, p_Recv->Frame_Data, p_Recv->FrameSize);
			*num = p_Recv->FrameSize;
			break;
		case TAG_CMDTT:
			memcpy(IMSI, p_Recv->Frame_Data, 9);//add bylk 20150304
			memcpy(TempBuf, p_Recv->Frame_Data + 9, *num);
			break;
		case TAG_HB_NEW: //add by lk 20150506
			*num = p_Recv->FrameSize;
			memcpy(TempBuf, p_Recv->Frame_Data, *num);
			break;
		case TAG_LOW_VSIM:
		case TAG_LOGOUT://add by lk 20160611
		case TAG_CFMD:
			memcpy(TempBuf, p_Recv->Frame_Data, p_Recv->FrameSize);
			*num = p_Recv->FrameSize;
			break;
		case TAG_LOCAL_STA:
			memcpy(IMSI, p_Recv->Frame_Data, 9);//add by lk 20150304
			memcpy(TempBuf, p_Recv->Frame_Data, p_Recv->FrameSize);
			*num = p_Recv->FrameSize;
			break;
		case TAG_HB:
			memcpy(TempBuf, p_Recv->Frame_Data, p_Recv->FrameSize);
			break;
		case TAG_IP://add by lk 20150518
			printf("This come from TAG_IP \n");
			break;
		default:
			break;
	}

	return CMD_TAG;	
}

int PickUp_Data_Spm(int CMD, unsigned char *IMSI, unsigned char *Buff, unsigned char *Dst, int len, Data_Spm *para, int *Socket, char *sIMSI)
{
    Tdm_to_Spm Data;
    memset(&Data, 0, sizeof(Data));

	if(*Socket <= 0)
	{
		if(para->port == -1)
		{
			int ret = Get_Data_IP_SN(sIMSI, para);
			if(ret)
			{
				LogMsg(MSG_ERROR, "the %s:imsi->%s spmIp is %s, the spm_port is %d, the ret is %d\n", __func__, sIMSI, para->spmIp, para->port, ret);
				return 0;
			}
		}

		if(para->port > 0)
		{
			*Socket = ConnectToServer(para->spmIp, para->port);
        	if(*Socket <= 0)
        	{
				Set_SimCards_Status(sIMSI, 0);//add by lk 20150928
				LogMsg(MSG_ERROR, "the %s:%d imsi->%s spmIp is %s, spm_port is %d, the err is %s\n", __func__, __LINE__, sIMSI, para->spmIp, para->port, strerror(errno));
				return 0;
        	}
		}
	}

    Data.Cmd = CMD;
    Data.len = len;
	Data.SimBank_ID = para->SimBank_ID; //add by lk 20150909
	Data.Channel_ID = para->Channel_ID;//add by lk 20150909

	if((len > 0) && (Buff != NULL))
    	memcpy(Data.buff, Buff, len);

	if(IMSI)
    	memcpy(Data.imsi, IMSI, 9);

    memcpy(Dst, &Data, sizeof(Data));

    return (sizeof(Data));
}

/*****************************************************************************************
SendMsg：
	该函数主要是用于发送socket数据
	输入参数:
		SendBuf：发送的数据内容
		iclient_sock：socket文件描述符
		sendbytes：发送数据的长度
	输出参数：无
******************************************************************************************/
int SendMsg(char *SendBuf, int iclient_sock, int sendbytes)
{
	//pthread_mutex_lock(&msg_mutex);
	int cnt = PutMsgToSock(iclient_sock, SendBuf, sendbytes);
	//pthread_mutex_unlock(&msg_mutex);

	return cnt;
}

int Data_Coding_Spm(Data_Spm *para, unsigned char *Src, int len, unsigned char *Dst, int *Socket, char *sIMSI)
{
	int sendbytes = -1;

	sendbytes = SendMsg((char *)Src, *Socket, len);
    if(sendbytes <= 0)
    {
		sendbytes = -12;
		LogMsg(MSG_ERROR, "SendMsg to SPM faild!, the errno is %d, err is %s\n", errno, strerror(errno));
        goto err;
    }

	memset(Dst, 0, RecvBufSize);
	sendbytes = GetMsgFromSock(*Socket, (char *)Dst, 0, 0, 2);
	if(sendbytes <= 0)
    {
		sendbytes = -13;
		LogMsg(MSG_ERROR, "Get data from SPM faild!, the errno is %d, err is %s\n", errno, strerror(errno));
err:
		close(*Socket);
     	*Socket = -1;
    }

	return sendbytes;	
}

int Send_Change_IP(char *SN, int code, int CMD, int socket_fd)
{
	unsigned char buff[4];
	int sendbytes = 4;
	memset(buff, 0, sizeof(buff));

	buff[0] = TAG_IP;
	printf("This come from TAG_IP, the SN is %s\n\n", SN);
    Set_Deal_From_SimPool(SN, NULL, code, 0, NULL);
	PutMsgToSock(socket_fd, (char *)buff, sendbytes);

	return 0;
}

int Coding_With_HB(int socket_fd, int num, char *SN, unsigned char *IMSI, unsigned char *TempBuf, char *sIMSI)
{
	unsigned char buff[4];
	int sendbytes = 4;

	if(num != 0)
	{
	    heartBeatWithData_t heartBeat;
	    memset(&heartBeat, 0, sizeof(heartBeat));
	    memcpy(&heartBeat, TempBuf, sizeof(heartBeat));
	    memcpy(IMSI, heartBeat.IMSI, 9);
	    memcpy(SN, heartBeat.SN, 16);
		SN[15] = '\0'; //add by lk 20150514
	
		Hex2String(IMSI, sIMSI, LEN_OF_IMSI);
		if(!strcmp(sIMSI, "000000000000000000"))
		{
			printf("the imsi is wrong!\n");
			return -1;
		}	
	}
	
	printf("this come from TAG_HB: the sn is %s, the socket fd is %d\n\n", SN, socket_fd);
	memset(buff, 0, sizeof(buff));
	buff[0] = TAG_HB_RET;
	PutMsgToSock(socket_fd, (char *)buff, sendbytes);
	
	Set_SimCards_Status(sIMSI, 2);//add by lk 20150928

	return 0;
}

int Coding_With_NewHB(int socket_fd, char *SN, unsigned char *TempBuf, char *sIMSI, int *type)
{
	unsigned char buff[4];
	int sendbytes = 4;
	memset(buff, 0, sizeof(buff)); //add by lk 20150902
	buff[0] = TAG_HB_NEW_RET;

	PutMsgToSock(socket_fd, (char *)buff, sendbytes);
	printf("this come from TAG_HB_NEW: the sn is %s,the socket fd is %d\n\n", SN, socket_fd);
	*type = 1;
	Heart_Log(SN, sIMSI, (HB_NEW_t *)TempBuf);
	SetFd_From_Device(SN, socket_fd, -1); //add by lk 20150326

	return 0;
}

int Coding_With_CFMD(int socket_fd, char *SN, char *sIMSI, unsigned char *TempBuf, int num)
{
	unsigned char buff[128];
	unsigned char sBuff[256];
	char Config[40] = {'\0'};
	int len = 4;
	int sendbytes = -1;
	int minite_Remain = -1;
	Tell_Server_Bill Tell_Server_para;

	memset(buff, 0 , sizeof(buff));
	memset(sBuff, 0 , sizeof(sBuff));
	memset(&Tell_Server_para, 0, sizeof(Tell_Server_Bill));
	memcpy(&Tell_Server_para, TempBuf, num);
	memcpy(SN, Tell_Server_para.SN, 16);
	SN[15] = '\0';
	Hex2String(Tell_Server_para.Imsi, sIMSI, LEN_OF_IMSI);
	printf("The SN:%s Vsim_Action_State is %d, the MCC is %d\n", SN, Tell_Server_para.Vsim_Action_State, Tell_Server_para.MCC);

	if(Tell_Server_para.Vsim_Action_State)
	{
		//Modify_Sim_Status(sIMSI);		
	}
	else
	{
		if(Get_Data_Config(Tell_Server_para.MCC, Config))
		{
			LogMsg(MSG_ERROR, "%s->faild!, SN->%s the errno is %d, err is %s\n", __func__, SN, errno, strerror(errno));
		}
		else
		{
			memcpy(buff + 4, Config, strlen(Config));
        	len = 4 + strlen(Config);
		}
	}

	Set_Deal_From_SimPool(SN, sIMSI, Tell_Server_para.MCC, 0, &minite_Remain);//add by lk 20150713
	memcpy(buff, &minite_Remain, 4);	
	sendbytes = TT_Result_Pack1(buff, (TD_ComProtocl_SendFrame_t *)sBuff, len, TAG_CFMD, 0);
	PutMsgToSock(socket_fd, (char *)sBuff, sendbytes);
	Tell_Server_para.Version[10] = '\0';//add by lk 20150914
	printf("This come from TAG_CFMD:%s the minite_Remain is %d, the Config is %s, the Version is %s\n", SN, minite_Remain, Config, Tell_Server_para.Version);
	Local_Confirm(SN, sIMSI, (char *)Tell_Server_para.Version);
	SetFd_From_Device(SN, 0, socket_fd); //add by lk 20150326

	Set_SimCards_Status(sIMSI, 2);//add by lk 20150928

	return 0;
}

int Coding_With_Low_Vsim(int socket_fd, unsigned char *TempBuf, int num, char *sIMSI)
{
	int sendbytes = -1;
	unsigned char SendBuf[128];
	memset(SendBuf, 0, sizeof(SendBuf));//add by lk 20150908

	unsigned char temp_imsi[12] = {'\0'};
	unsigned char IMSI_T[10] = {'\0'};
	Rqst_Low_Vsim Low_Vsim_t;//add by lk 20150807
	memset(&Low_Vsim_t, 0, sizeof(Low_Vsim_t));
	memcpy(&Low_Vsim_t, TempBuf, num);
	sendbytes = Get_Low_simcards(Low_Vsim_t.SN, Low_Vsim_t.Mcc, temp_imsi);
	LogMsg(MSG_MONITOR, "This come from TAG_LOW_VSIM, the SN is %s, the ret is %d\n", Low_Vsim_t.SN, sendbytes);
	if(sendbytes)
	{
		sendbytes = TT_Result_Pack1(IMSI_T, (TD_ComProtocl_SendFrame_t *)SendBuf, 9, TAG_LOW_VSIM, sendbytes);//add by lk 20150408
		Set_SimCards_Status(sIMSI, 1);//add by lk 20150928
	}
	else
		sendbytes = TT_Result_Pack1(NULL, (TD_ComProtocl_SendFrame_t *)SendBuf, 0, TAG_LOW_VSIM, sendbytes);//add by lk 20150408

	PutMsgToSock(socket_fd, (char *)SendBuf, sendbytes);

	return 0;
}

int Coding_With_LogOut(int socket_fd, unsigned char *TempBuf, int num, int type, int *spm_fd)
{
	int sendbytes = 4;
	unsigned char SendBuf[4];
	Device_Logout logout_t;
	char sIMSI[18] = {'\0'};
	
	memset(SendBuf, 0, sizeof(SendBuf));
	memset(&logout_t, 0, sizeof(logout_t));
	memcpy(&logout_t, TempBuf, num);
	Hex2String(logout_t.Imsi, sIMSI, 9);

	SendBuf[0] = TAG_LOGOUT;
	PutMsgToSock(socket_fd, (char *)SendBuf, sendbytes);

	SetFd_From_Device(logout_t.SN, 0, 0);
	LOG_OUT_Log(logout_t.SN, sIMSI);

	if(*spm_fd > 0)
	{
		LogMsg(MSG_MONITOR, "This come from %s->close(socket_spm)\n", __func__);
		close(*spm_fd);
	}
	Set_SimCards_Status(sIMSI, 1);//add by lk 20150928

	return 0;
}

int Coding_With_ADN(int socket_fd, char *CallNum)
{
	int i;
	unsigned char SendBuf[258];
	memset(SendBuf, 0, sizeof(SendBuf));
	TD_ComProtocl_SendFrame_t *p_send = (TD_ComProtocl_SendFrame_t *)SendBuf;
	p_send->Cmd_TAG = TAG_ADN;
	p_send->Result = 0;
	p_send->FrameSizeL = strlen(CallNum);
	memcpy(p_send->Frame_Data, CallNum, p_send->FrameSizeL);	
	printf("this come from TAG_ADN: call_number is %s, the SendBuf is:\n", CallNum);
	for(i = 0; i < (p_send->FrameSizeL + 4); i++)
	{
		printf("%02x ", SendBuf[i]);
	}	
	printf("\n\n");
	
	PutMsgToSock(socket_fd, (char *)SendBuf, p_send->FrameSizeL + 4);

	return 0;
}

int Coding_With_Local(int socket_fd, char *SN, char *sIMSI, int *type, unsigned char *TempBuf, int *num)
{
	unsigned char SendBuf[4];
	int cnt = -1;
	Vsim_UpLoad_Flow Data;
	memcpy(&Data, TempBuf, sizeof(Data));
	memset(SendBuf, 0, sizeof(SendBuf));
	cnt = Data.Upload_Flow_Id;

	while(cnt > 255)
    {
        cnt = cnt - 256; //add by lk 20150427
    }

	printf("this come from TAG_LOCAL_STA, the sn is %s, the socket fd is %d, the cnt is %d\n\n", SN, socket_fd, cnt);
	SendBuf[0] = TAG_LOCAL_STA_RET;
	SendBuf[4] = cnt;
	send(socket_fd, (char *)SendBuf, 4, 0);

	Local_Log(SN, sIMSI, &Data);
	*type = 2;

	cnt = *num;
	if((1 == cnt) || (0 == (cnt % 6)))
	{
		SetFd_From_Device(SN, 0, socket_fd); //add by lk 20150326
	}

	if(0 == (cnt % 10))
	{
		Set_SimCards_Status(sIMSI, 2);//add by lk 20150928
	}

	*num = cnt++;

	return 0;
}

int Coding_With_APN(int socket_fd, char *APN)
{
	unsigned char SendBuf[SendBufSize];
	memset(SendBuf, 0, sizeof(SendBufSize));//add by lk 20150908
	TD_ComProtocl_SendFrame_t *p_send = (TD_ComProtocl_SendFrame_t *)SendBuf;
	p_send->Cmd_TAG = TAG_GET_APN_INFO;
	p_send->Result = 0;
	p_send->FrameSizeL = strlen(APN);
	memcpy(p_send->Frame_Data, APN, p_send->FrameSizeL);	
	printf("this come from TAG_GET_APN_INFO: apn  is %s\n\n", APN);
	PutMsgToSock(socket_fd, (char *)SendBuf, p_send->FrameSizeL + 4);

	return 0;
}

int Coding_With_CMDTT(int socket_fd, unsigned char *TempBuf, Data_Spm *para, int num, int *socket_spm, char *sIMSI, int *type, int *cnt)
{
	*type = 1;
	int i;
	int sendbytes = -1;
	int result = 0;
	int ret = -1;
	unsigned char SendBuf[256];
	unsigned char RecvBuf[SendBufSize];
	memset(SendBuf, 0, sizeof(SendBuf));
	memset(RecvBuf, 0, SendBufSize);

	sendbytes = PickUp_Data_Spm(TAG_CMDTT, para->IMSI, TempBuf, SendBuf, num, para, socket_spm, sIMSI);
	if(sendbytes > 0)
		sendbytes = Data_Coding_Spm(para, SendBuf, sendbytes, RecvBuf, socket_spm, sIMSI);

    printf("This come from TAG_CMDTT: %s -> %s!, the cnt is %d, the sendbytes is %d, the Buff: \n", para->SN, sIMSI, (int)TempBuf[0], sendbytes);
    for(i = 0; i < sendbytes; i++)
    {
        printf("%02x ", RecvBuf[i]);
    }
    printf("\n\n");

	if(1 == sendbytes)
	{
		result = RecvBuf[0];
		switch(result)
		{
			case 1:
			case 2:
			case 3:
			case 6:
			case 7:
			case 8:
				sendbytes = TT_Result_Pack(NULL, (TD_ComProtocl_SendFrame_t *)RecvBuf, 1, TAG_RESULT_CMDTT, TempBuf[0]);
				ret = Set_SimCards_Status(sIMSI, 0);//add by lk 20150917
				LogMsg(MSG_ERROR, "the %s->Set_Sim_Status return %d\n", __func__, ret);
				break;
			case 4:
			case 5:
			case 9:
			case 10:
			case 11:
				printf("this come from -10\n");
				sendbytes = TT_Result_Pack(NULL, (TD_ComProtocl_SendFrame_t *)RecvBuf, 2, TAG_RESULT_CMDTT, TempBuf[0]);
				break;
			default:
				break;
		}
		printf("the result is %d, the RecvBuf[0] is %d\n", result, RecvBuf[0]);
		TT_Log(para->SN, (int)TempBuf[0], sIMSI, RecvBuf, -result);//modify by lk 20150908
	}
	else if(sendbytes > 1)
	{
		TT_Log(para->SN, (int)TempBuf[0], sIMSI, RecvBuf, sendbytes);//modify by lk 20150908
		memset(SendBuf, 0, sizeof(SendBufSize));//add by lk 20150908
		sendbytes = TT_Info_Process(RecvBuf, (TT_RESULT_t *)SendBuf, sendbytes);
		sendbytes = TT_Result_Pack((TT_RESULT_t *)SendBuf, (TD_ComProtocl_SendFrame_t *)RecvBuf, sendbytes, TAG_RESULT_CMDTT, TempBuf[0]);
	}
	else
	{
		TT_Log(para->SN, (int)TempBuf[0], sIMSI, RecvBuf, sendbytes);//modify by lk 20150908
	}

	if(sendbytes > 0)
		SendMsg((char *)RecvBuf, socket_fd, sendbytes);

	if(0 == *cnt)
	{
		SetFd_From_Device(para->SN, socket_fd, 0); //add by lk 20150326
		*cnt = 1;
	}

	return 0;
}

int Init_Data_Spm(Data_Spm *para)
{
	memset(para, 0, sizeof(Data_Spm));
	para->port = -1;
	para->SimBank_ID = -1;
	para->Channel_ID = -1;

	return 0;
}

int Coding_With_ACCESS_AUTH(int socket_fd, unsigned char *TempBuf, Data_Spm *para, int *code, char *sIMSI, int *type)
{
	AccessAuth_Result_t para1;
	memset(&para1, 0, sizeof(AccessAuth_Result_t));
	unsigned char SendBuf[SendBufSize];
	int sendbytes = -1;
	memset(SendBuf, 0, sizeof(SendBufSize));//add by lk 20150908

	SIM_Allocate_Proc(TempBuf, &para1, code);//add by lk 20150701
	sendbytes = AccessAuth_Result_Pack(&para1, (TD_ComProtocl_SendFrame_t *)SendBuf);
	sendbytes = SendMsg((char *)SendBuf, socket_fd, sendbytes);

	if((SendBuf[3] != AA_RESULT_STATE_SUCCESS) && (para1.factoryFlag != 1))
	{
		SetFd_From_Device(para->SN, 0, 0); //add by lk 20150326
		printf("this come from auth faild!\n");
		return -4;
	}

	Hex2String(para1.IMSI, sIMSI, LEN_OF_IMSI); //add by lk 20150902
	SimIMSI_Data_To_Mysql(sIMSI, para1.SN, para1.priority, para1.SIMInfoID);

	para->port = para1.port;
	para->SimBank_ID = para1.SimBank_ID;
	para->Channel_ID = para1.Channel_ID;
    memcpy(para->spmIp, para1.ip, strlen(para1.ip));
	memcpy(para->SN, para1.SN, 15);
	memcpy(para->IMSI, para1.IMSI, 9); //add by lk 20150330

	if(para1.Vusim_Active_Flag)
	{
		memcpy(para->CallNum, para1.Vusim_Active_Num, strlen(para1.Vusim_Active_Num));
	}
	
	if(para1.IsApn)
	{	
		memcpy(para->APN, para1.apn, strlen(para1.apn));
	}

	LogMsg(MSG_MONITOR, "Client_Manage:Client Access Authenticate success!, the fd is %d, send %d bytes, SN is %s\n\n", socket_fd, sendbytes, para->SN);
	SetFd_From_Device(para->SN, socket_fd, 0); //add by lk 20150326
	*type = 1;
	
	return 0;
}

int Coding_With_SIMFILE_REQUEST(int socket_fd, Data_Spm *para, unsigned char *TempBuf, int num, char *sIMSI, int *socket_spm)
{
	int sendbytes = -1;
	unsigned char SendBuf[SendBufSize];
	unsigned char RecvBuf[SendBufSize];
	memset(SendBuf, 0, sizeof(SendBuf));
	memset(RecvBuf, 0, sizeof(SendBuf));

	printf("This come from TAG_SIMFILE_REQUEST:the SN is %s, the ip is %s, port is %d\n", para->SN, para->spmIp, para->port);
	sendbytes = PickUp_Data_Spm(TAG_SIMFILE_REQUEST, para->IMSI, TempBuf, SendBuf, num, para, socket_spm, sIMSI);
	if(sendbytes > 0)
		sendbytes = Data_Coding_Spm(para, SendBuf, sendbytes, RecvBuf, socket_spm, sIMSI);
	printf("The TAG_SIMFILE_REQUEST: recv %d bytes from spm\n", sendbytes);

	if(1 == sendbytes)
	{
		Set_SimCards_Status(sIMSI, 0);//add by lk 20150917
	}
	else if(sendbytes > 1)
	{
		SendMsg((char *)RecvBuf, socket_fd, sendbytes);
	}

	return 0;
}

int Coding_With_Err(int type, int spm_fd, char *SN)
{
	printf("this come from TAG_ERR the errno is %d, the sn is %s, len of SN is %d\n\n", errno, SN, (int)(strlen(SN)));
	if(spm_fd > 0)
	{
		LogMsg(MSG_MONITOR, "This come from %s->close(socket_spm)\n", __func__);
		close(spm_fd);
	}

	if(1 == type)
	{
		SetFd_From_Device(SN, 0, -1); //add by lk 20150326
	}

	return 0;
}

int Coding_With_TAG_CMD(int CMD, Data_Spm *para, char *sIMSI)
{
	int ret = -1;

	if((CMD == TAG_CMDTT) || (TAG_LOCAL_STA == CMD) || (TAG_SIMFILE_REQUEST == CMD))
	{
		Hex2String(para->IMSI, sIMSI, LEN_OF_IMSI);
		if(!strcmp(sIMSI, "000000000000000000"))
		{
			printf("the imsi is wrong!\n");
			return -1;
		}	

		switch(CMD)
		{
			case TAG_CMDTT:
				if((-1 == para->port) && (!strlen(para->SN)))
				{
					ret = Get_Data_IP_SN(sIMSI, para);
					if(ret)
					{
						LogMsg(MSG_ERROR, "the %s:imsi->%s spmIp is %s, the spm_port is %d\n", __func__, sIMSI, para->spmIp, para->port);
					}
				}
				break;
			case TAG_LOCAL_STA:
				if((!strlen(para->SN)))
				{
					ret = Get_Data_IP_SN(sIMSI, para);
					if(ret)
					{
						LogMsg(MSG_ERROR, "the %s:imsi->%s spmIp is %s, the spm_port is %d\n", __func__, sIMSI, para->spmIp, para->port);
					}
				}
				break;
			default:
				break;
        }
	}

	return 0;
}

void Printf(void *Src, int len)
{
	int i;
	char *p = (char *)Src;
	printf("\nthe address of Src is%p->", Src);
	for(i = 0; i < len; i++)	
	{
		printf(" %02x", p[i]);
	}
	printf("\n");
}
/*****************************************************************************************
Client_Manage：
	该函数主要是用于处理和终端数据的交互
	输入参数:
		data： mongoDB数据结构体指针
		iclient_sock：socket文件描述符
		ICCID： iccid数据
	输出参数：非零为失败并退出while循环，零值为正常退出
******************************************************************************************/
int Client_Manage(int iclient_sock, unsigned char *ICCID, char *ip)
{
	unsigned char TempBuf[RecvBufSize];
	int num = 0, code = -1, CMD_TAG = 0, type = 0, socket_spm = -1, cnt = 0;
	char sIMSI[32] = {'\0'};
	Data_Spm Data_Spm_t;
	Init_Data_Spm(&Data_Spm_t);

	while(1)
	{
		CMD_TAG = GetMsgFromSocket(iclient_sock, &num, Data_Spm_t.IMSI, TempBuf);
		if(Coding_With_TAG_CMD(CMD_TAG, &Data_Spm_t, sIMSI))
			return -1;

		switch(CMD_TAG)
		{
			case TAG_ERR:
			{
				Coding_With_Err(type, socket_spm, Data_Spm_t.SN);
				goto ret;
			}
			case TAG_ACCESS_AUTH:
			{
				if(Coding_With_ACCESS_AUTH(iclient_sock, TempBuf, &Data_Spm_t, &code, sIMSI, &type))
					goto ret;

				break;
			}	
			case TAG_ADN:
			{
				Coding_With_ADN(iclient_sock, Data_Spm_t.CallNum);
				break;
			}
			case TAG_GET_APN_INFO:
			{
				Coding_With_APN(iclient_sock, Data_Spm_t.APN);
				break;
			}
			case TAG_SIMFILE_REQUEST: //add by ywy 2015-03-05
			{
				Coding_With_SIMFILE_REQUEST(iclient_sock, &Data_Spm_t, TempBuf, num, sIMSI, &socket_spm);
				break;
			}
			case TAG_IP://add by lk 20150518
			{
				Send_Change_IP(Data_Spm_t.SN, code, TAG_IP, iclient_sock);
				goto ret;
			}
			case TAG_CMDTT:
			{
				Coding_With_CMDTT(iclient_sock, TempBuf, &Data_Spm_t, num, &socket_spm, sIMSI, &type, &cnt);
				break;
			}
			case TAG_HB:
            {
				Coding_With_HB(iclient_sock, num, Data_Spm_t.SN, Data_Spm_t.IMSI, TempBuf, sIMSI);
                break;
            }
			case TAG_HB_NEW:
			{
				Coding_With_NewHB(iclient_sock, Data_Spm_t.SN, TempBuf, sIMSI, &type);
				break;
			}
			case TAG_CFMD:
			{
				Coding_With_CFMD(iclient_sock, Data_Spm_t.SN, sIMSI, TempBuf, num);
				break;
			}
			case TAG_LOCAL_STA:
			{
				Coding_With_Local(iclient_sock, Data_Spm_t.SN, sIMSI, &type, TempBuf, &cnt);
				break;
			}
			case TAG_CONF_FILE_UPDATE:
			{
				printf("this come from TAG_CONF_FILE_UPDATE\n");
				break;
			}
			case TAG_LOGOUT://add by lk 20150611
			{
				Coding_With_LogOut(iclient_sock, TempBuf, num, type, &socket_spm);
				goto ret;
			}
			case TAG_LOW_VSIM://add by lk 20150720
			{
				Coding_With_Low_Vsim(iclient_sock, TempBuf, num, sIMSI);
				break;
			}
			default:
				break; 
		}
	}

ret:
	return 0;
}

int PickUp_Web_Data(TD_ComProtocl_SendFrame_t *para, int len, void *Src, int fd1, int fd2)
{
	int sendbytes = 0;
	int i;
	unsigned char SendBuf[512];
	memset(SendBuf, 0, sizeof(SendBuf));

    para->FrameSizeL = len;
    sendbytes = 4 + len;

	if(len > 0)
    	memcpy(para->Frame_Data, (char *)Src, len);

	printf("the para->CMD_TAG is %x, the SendBuf is :\n", para->Cmd_TAG);
    memcpy(SendBuf, para, sendbytes);
	for(i = 0; i < sendbytes; i++)
	{
		printf("%02x ", SendBuf[i]);
	}
	printf("\n");
	
    if(fd2 > 0)
    {
        PutMsgToSock(fd2, (char *)SendBuf, sendbytes);
    }
    else if((fd1 > 0) && (fd2 <= 0))
    {
        PutMsgToSock(fd1, (char *)SendBuf, sendbytes);
    }

	return 0;
}

/*****************************************************************************************
Client_Web_Manage：
	该函数主要是用于处理和Web数据请求的交互
	输入参数:
		data： mongoDB数据结构体指针
		iclient_sock：socket文件描述符
	输出参数：非零为失败，零值为正常退出
******************************************************************************************/
int Client_Web_Manage(int iclient_sock)
{
	unsigned char RecvBuf[RecvBufSize] = {'\0'};
    int recvbytes = 0, fd1 = 0, fd2 = 0;
    char sn[16] = {'\0'};
    char dst[256] = {'\0'};
    TD_ComProtocl_SendFrame_t para;
    Web_Data para1;
    memset(&para, 0, sizeof(para));
    memset(&para1, 0, sizeof(para1));

    recvbytes = read(iclient_sock, (char *)RecvBuf, RecvBufSize);
    if(recvbytes <= 0)
    {
        printf("the errno is %d, the recvbytes is %d\n\n", errno, recvbytes);
        return -1;
    }

    printf("this come from TAG_WEB, the RecvBuf is %s\n\n", RecvBuf);
    getValue(&para1, sn, (char *)RecvBuf, dst);//add by lk 20150525
    GetFd_From_Device(sn, &fd1, &fd2);
    printf("the type is %d, the num is %d\n", para1.type, para1.num);
    printf("the sn is %s ,the para.FrameSizeH = %d, para.Result = %d\n", sn, para.FrameSizeH, para.Result);
    printf("the dst is %s, the len of dst is %d\n", dst, (int)strlen(dst));
	if((fd1 == 0) && (fd2 == 0))
		return -2;

    switch(para1.type)
    {
        case Web_Rom_Log:
        case Web_Loc_Log:
            para.Cmd_TAG = TAG_WEB_RET;
			PickUp_Web_Data(&para, 2, &para1, fd1, fd2);
			break;
        case Web_Rom_Up:
            para.Cmd_TAG = TAG_UPDATE_ROAM;
			PickUp_Web_Data(&para, 2, &para1, fd1, fd2);
			break;
        case Web_Loc_Up:
            para.Cmd_TAG = TAG_UPDATE_LOCAL;
			PickUp_Web_Data(&para, 2, &para1, fd1, fd2);
			break;
        case Web_Rom_Up_Apk:
            para.Cmd_TAG = TAG_UPDATE_ROAM_APK;
			PickUp_Web_Data(&para, 2, &para1, fd1, fd2);
			break;
		case Web_Loc_Up_Apk:
            para.Cmd_TAG = TAG_UPDATE_LOCAL_APK;
			PickUp_Web_Data(&para, 2, &para1, fd1, fd2);
			break;
        case Web_MIP_Up:
            para.Cmd_TAG = TAG_UPDATE_MIP;
			PickUp_Web_Data(&para, 2, &para1, fd1, fd2);
			break;
        case Web_iMsg:
            para.Cmd_TAG = TAG_MSG;
			PickUp_Web_Data(&para, strlen(dst), dst, fd1, fd2);
            break;
        case Web_SWAP_VUSIM://add by lk 20150531
            printf("this come from TAG_SWAP_VUSIM, the fd1 is %d\n", fd1);
            para.Cmd_TAG = TAG_SWAP_VUSIM;
			PickUp_Web_Data(&para, 0, NULL, fd1, fd2);
            break;
        case Web_SPEED:
            para.Cmd_TAG = TAG_LIMIT_SPEED_CMD;
			PickUp_Web_Data(&para, strlen(dst), dst, fd1, fd2);
			break;
		case Web_APN:
            para.Cmd_TAG = TAG_APN;
			PickUp_Web_Data(&para, strlen(dst), dst, fd1, fd2);
            break;
        case Web_VPN:
            para.Cmd_TAG = TAG_VPN_CMD;
			PickUp_Web_Data(&para, strlen(dst), dst, fd1, fd2);
            break;
        case Web_AUTONET:
            para.Cmd_TAG = TAG_AUTONET;
			PickUp_Web_Data(&para, strlen(dst), dst, fd1, fd2);
            break;
        case Web_Reinsert_Sim: //ywy add 150811
            para.Cmd_TAG = TAG_REINSERT_VSIM_CMD;
			PickUp_Web_Data(&para, 0, NULL, fd1, fd2);
            break;
        case Web_Remote_shutdown: //ywy add 150811
            para.Cmd_TAG = TAG_SHUTDOWN_CMD;
			PickUp_Web_Data(&para, 0, NULL, fd1, fd2);
            break;
        default:
            break;
    }

    return 0;
}

void *Manage_SimCards(void *arg)
{
	pthread_detach(pthread_self());
	
	while(1)
	{
		Manage_SimCards_Status();
		sleep(5);
	}

	pthread_exit(NULL);	
}
/*****************************************************************************************
client_func：
	该函数主要是用于线程主函数
	输入参数:
		arg：线程函数所需结构体指针
	输出参数：正常退出线程
******************************************************************************************/
static void *client_func(void *arg)
{
	tmd_pthread client; // = (tmd_pthread *)arg;
	memset(&client, 0, sizeof(client));
	memcpy(&client, arg, sizeof(client));
	pthread_detach(pthread_self());

	Client_Manage(client.client_sockfd, client.iccid, client.clientIP);
	close(client.client_sockfd);

	pthread_exit(0);
}

/*****************************************************************************************
TDM_init：
	该函数主要是用于初始化TDM程序
	输入参数:
		iServer_sock：用于保存创建的监听socket文件描述符
	输出参数：非零为失败，零值为正常退出
******************************************************************************************/
int TDM_init(int *iServer_sock)
{
	pthread_t sim_manage;
	int iListenPort;
	char sListenPort[8];
	char SC_PATH[128];
	SetMsgLevel(TDM_LOG_LEVEL);
	RegisterLogMsg(TDM_LOG_FILE_NAME, TDM_LOG_FILE_NAME_ERR, TDM_LOG_LEVEL);
	strcpy(SC_PATH, "/home/SubServer");
	strcat(SC_PATH, SERVER_CONFIG);
	ReadString(SC_PATH, "sub_server", "socket", "port", sListenPort);
	iListenPort = atoi(sListenPort);

	LogMsg(MSG_MONITOR, "TDM:Listen to Port %d\n", iListenPort);
	*iServer_sock = CreateListenService(iListenPort, MAX_Connect);
	if((*iServer_sock) < 0)
	{
		LogMsg(MSG_ERROR, "TDM:Listen to port %d error,erro info is %d\n", iListenPort, *iServer_sock);
	}

	ConnectToMysqlInit(&Data_Fd);
	ConnectToMysql(&Data_Fd);
	pthread_create(&sim_manage, NULL, Manage_SimCards, NULL);

	return 0;
}

/*****************************************************************************************
sig_chld：
	该函数主要是用于扑捉进程退出
	输入参数:
		signo：信号值
	输出参数：无
******************************************************************************************/
static void sig_chld(int signo)  
{
    while( waitpid(-1, NULL, WNOHANG) > 0 );  
    return;  
}

void *Create_Epoll_Pthread(void *arg)
{
	pthread_detach(pthread_self());
	int socket = *(int *)arg;
    int connfd, kdpfd, nfds, n, curfds = 0;
    struct epoll_event ev;
    struct epoll_event events[MAXEPOLLSIZE];
    struct sockaddr_in cliaddr;
    socklen_t socklen = sizeof(struct sockaddr_in);
    char buf[MAXLINE];

    kdpfd = epoll_create(MAXEPOLLSIZE);
    ev.events = EPOLLIN;
    ev.data.fd = socket;
    if (epoll_ctl(kdpfd, EPOLL_CTL_ADD, socket, &ev) < 0)
    {
        fprintf(stderr, "epoll set insertion error: fd=%d\n", socket);
        return NULL;
    }

    curfds = 1;

    while(1)
    {
        nfds = epoll_wait(kdpfd, events, curfds, -1);
        if (nfds == -1)
        {
			if(errno == EINTR)
            	continue;
			else
			{
            	perror("epoll_wait");
				LogMsg(MSG_ERROR, "epoll_wait error, %s", strerror (errno));
				exit(0);
			}
        }

        for(n = 0; n < nfds; n++)
        {
            if(events[n].data.fd == socket)
            {
                connfd = accept(socket, (struct sockaddr *)&cliaddr, &socklen);
                if (connfd < 0)
                {
                    perror("accept error");
                    continue;
				}
				sprintf(buf, "accept form %s:%d\n", inet_ntoa(cliaddr.sin_addr), cliaddr.sin_port);
                printf("%s", buf);

                if (curfds >= MAXEPOLLSIZE)
                {
                    fprintf(stderr, "too many connection, more than %d\n", MAXEPOLLSIZE);
                    close(connfd);
                    continue;
                }

				if (setnonblocking(connfd) < 0) 
				{
					perror("setnonblocking error");
				}

                ev.events = EPOLLIN | EPOLLET;
                ev.data.fd = connfd;
                if (epoll_ctl(kdpfd, EPOLL_CTL_ADD, connfd, &ev) < 0)
                {
                    fprintf(stderr, "add socket '%d' to epoll failed: %s\n", connfd, strerror(errno));
                    continue;
                }
                curfds++;
                continue;
            }

			Client_Web_Manage(events[n].data.fd);
			close(events[n].data.fd);//add by lk 20150901
			epoll_ctl(kdpfd, EPOLL_CTL_DEL, events[n].data.fd, &ev);
			curfds--;
        }
    }

	pthread_exit(NULL);
}

/*****************************************************************************************
TDM_Proc：
	该函数主要是TDM程序监听终端设备的主函数
	输入参数:
		iServer_sock：监听的socket文件描述符
	输出参数：无
******************************************************************************************/
int TDM_Proc(int iServer_sock)
{
	int client_sockfd = -1;
	char  clientIP[20] = {'\0'};
	
	while(1)
	{
		client_sockfd = AcceptConnection(iServer_sock, clientIP);
		if(client_sockfd < 0)
		{
			LogMsg(MSG_ERROR, "%s->AcceptConnection errno is %d, the err is %s\n", __func__, errno, strerror(errno));
			if((24 == errno) || (-10 == client_sockfd))
			{
				exit(0);
			}
			continue;
		}
		else
		{
			printf("There is a new socket come in, the socket is %d, the clientIP is %s\n", client_sockfd, clientIP);
			tmd_pthread client;
			memset(&client, 0, sizeof(client));
			client.client_sockfd = client_sockfd;
			memcpy(client.clientIP, clientIP, strlen(clientIP) + 1);
			client.pthread_type = 0;
			
			if(pthread_create(&client.client_t, NULL, client_func, &client))
			{
				perror("pthread_create");
			}
		}
	}

	return 0;
}

/*****************************************************************************************
TDM_Web_Proc：
	该函数主要是TDM程序监听Web的主函数
	输入参数:
		iServer_sock：监听的socket文件描述符
	输出参数：无
******************************************************************************************/
void *TDM_Web_Proc(void *arg)
{
	int iServer_sock = *(int *)arg; 
	int client_sockfd = -1;
	pthread_detach(pthread_self());
	char clientIP[40] = {'0'};
	tmd_pthread client;

	if(mysql_fd <= 0)
	{
lk:
		pthread_mutex_lock(&mysql_mutex);
		mysql_fd = ConnectToServer(ServerIp, ServerPort);
		if(mysql_fd <= 0)
		{
			perror("connect");
			sleep(1);
			goto lk;
		}
		pthread_mutex_unlock(&mysql_mutex);
	}
	
	while(1)
	{
		client_sockfd = AcceptConnection(iServer_sock, clientIP);
		if(client_sockfd < 0)
		{
			perror("accept");
			continue;
		}
		else
		{
			memset(&client, 0, sizeof(client));
			memcpy(client.clientIP, clientIP, strlen(clientIP) + 1);
			client.pthread_type = 1;
			
			if(pthread_create(&client.client_t, NULL, client_func, &client))
			{
				perror("pthread_create");
			}
		}
	}

	pthread_exit(0);
}

int main(int argc, char ** argv )
{
	pthread_t web_t;
	int server_Sockfd = -1;
	do{
		TDM_init(&server_Sockfd);
		if(server_Sockfd > 0) break;
		sleep(5);
	}while(server_Sockfd < 0);

	signal(SIGINT, sigexit);
	signal(SIGSEGV, sigexit);

    if( signal(SIGCHLD, sig_chld) == SIG_ERR )  
	{  
        perror("signal(SIGCHLD) error");  
        exit(errno);  
	}

	memset(locale_ip, 0, 20);
    GetLocalIp(locale_ip); //add by lk 20150305

	int server_Sockfd1 = CreateListenService(10162, MAX_Connect);
	if(server_Sockfd1 > 0)
	{
		//pthread_create(&web_t, NULL, TDM_Web_Proc, &server_Sockfd1);
		pthread_create(&web_t, NULL, Create_Epoll_Pthread, &server_Sockfd1);
	}

#if 1
	TDM_Proc(server_Sockfd);
#else
	Create_Epoll_Pthread(server_Sockfd);
#endif

	return 0;
}
